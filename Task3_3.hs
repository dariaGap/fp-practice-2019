module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

-- Для функции (<>) реализующей добавление одного множества к другому, 
-- реализуем операцию объединения множеств, хотя возможен вариант с пересечением множеств 
instance Semigroup (PSet a) where
    (<>) (PSet x) (PSet y) = PSet (\t -> (x t) || (y t))

-- Пустое множество представляем как множество, для любого элемента дающего False
instance Monoid (PSet a) where
    mempty = PSet (\t -> False)

-- Реализовать fmap для PSet невозможно, так как по определению fmap принимает функцию f :: a -> b
-- и множество (PSet x), где x - условие вхождения элемента в множество и имеет тип x :: a -> Bool.
-- Результатом работы fmap должно быть множество (PSet y), где y - условие вхождения элемента в множество и имеет тип y :: b -> Bool.
-- Таким образом, при формировании множества (PSet y) на основе (PSet x) возникает необходимость передачи преобразованного с помощью f элемента
-- в условие x (пример релизации приведен ниже), но так как результатом работы f является тип b, возникает противоречие, поскольку
-- x не может принять тип b. 
--instance Functor PSet where
--    fmap f (PSet x) = PSet (\t -> x (f t))